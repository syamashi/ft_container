
--- [1]:alloc_test ---
size:0 capacity:0
{ }
size:5 capacity:5
{ 123 123 123 123 123 }
size:5 capacity:5
{ 100 123 123 123 123 }
size:5 capacity:5
{ 123 123 123 123 123 }
size:5 capacity:5
{ 123 123 123 123 123 }

--- [2]:traits_reverse ---
size:5 capacity:8
{ 4 3 2 1 0 }

--- [3]:traits_advance ---
The sixth element in mylist is: 50
The three element in mylist is: 20

--- [4]:traits_backinserter ---
foo contains: 1 2 3 4 5 10 20 30 40 50

--- [5]:traits_frontinserter ---
foo contains: 50 40 30 20 10 1 2 3 4 5

--- [6]:traits_inserter ---
foo contains: 1 2 3 10 20 30 40 50 4 5

--- [7]:reverse_iterator ---
5 4 3 2 1 0 

--- [8]:rit_operator= ---
2

--- [9]:rit_base ---
*it == 3
*r_it == 2
*r_it.base() == 3
*(r_it.base()-1) == 2
0 1 2 3 4 5 
5 4 3 2 1 0 

--- [10]:rit_op_ref ---
*r0 = 3
vi[3] = 42
*r1 = 1

--- [11]:rit_op_block ---
3 2 1 0 

--- [12]:rit_ops ---
3 4 1 1 4

--- [13]:rit_nonmember_ops ---
*x == 3
*y == 3
*z == 2
x == y ? true
x != y ? false
x <  y ? false
x <= y ? true
x == z ? false
x != z ? true
x <  z ? true
x <= z ? true

--- [14]:rit_nonmember_op_plus ---
3 1 
--- [15]:rit_nonmember_op_minus ---
4 -4

--- [16]:vector_construct_iter_iter_test ---
size:3 capacity:3
{ 5 5 5 }
size:3 capacity:3
{ 5 5 5 }

--- [17]:vector_copy_constructer ---
size:3 capacity:3
{ 1 1 1 }
size:3 capacity:3
{ 1 1 1 }

--- [18]:vector_assign_test ---
size:5 capacity:5
{ a a a a a }
size:6 capacity:6
{ b b b b b b }
size:3 capacity:6
{ c c c }
size:0 capacity:6
{ }
size:10 capacity:10
{ e e e e e e e e e e }

--- [19]:vector_at_test ---
test data init 1,2,4,4,5,6
size:6 capacity:8
{ 1 2 4 4 5 6 }
Element at index 2 has value 4
size:6 capacity:8
{ 1 88 4 4 5 6 }

--- [20]:vector_operator[]_test ---
Second element: 4
size:4 capacity:4
{ 5 4 6 8 }

--- [21]:vector_front_test ---
The first character is 'o'.

--- [22]:vector_back_test ---
The last character is 'f'.

--- [23]:vector_data_test ---
data = 1 2 3 4 

--- [24]:vector_begin_test ---
1 2 4 8 16 
Sum of nums: 31
First fruit: orange
vector 'empty' is indeed empty.

--- [25]:vector_rbegin_test ---
16 8 4 2 1 
Sum of nums: 31
First fruit: raspberry
vector 'empty' is indeed empty.

--- [26]:vector_empty_test ---
Initially, numbers.empty(): true
After adding elements, numbers.empty(): false

--- [27]:vector_max_size_test ---
Maximum size of a 'vector' is 18446744073709551615
Maximum size of a 'vector' is 4611686018427387903

--- [28]:vector_reserve_test ---
size:5 capacity:8
{ 0 1 2 3 4 }
size:5 capacity:8
{ 0 1 2 3 4 }
size:0 capacity:0
{ }
size:0 capacity:10000
{ }
size:3 capacity:4
{ 0 1 2 }
size:3 capacity:10000
{ 0 1 2 }

--- [29]:vector_capacity_test ---
initial capacity=0
new capacity=1
new capacity=2
new capacity=4
new capacity=8
new capacity=16
new capacity=32
new capacity=64
new capacity=128
new capacity=256
final size=200
final capacity=256

--- [30]:void vector_clear_test ---
Before clear:size:3 capacity:3
{ 1 2 3 }
Clear
After clear:size:0 capacity:3
{ }

--- [31]:vector_insert_test ---
size:3 capacity:3
{ 100 100 100 }
size:4 capacity:6
{ 200 100 100 100 }
size:6 capacity:6
{ 300 300 200 100 100 100 }
size:8 capacity:12
{ 300 300 400 400 200 100 100 100 }
size:10 capacity:12
{ 501 502 300 300 400 400 200 100 100 100 }

--- [32]:vector_erase_test ---
size:0 capacity:1
{ }
size:1 capacity:2
{ 0 }
size:0 capacity:2
{ }
size:4 capacity:8
{ 0 1 3 4 }
size:3 capacity:8
{ 0 1 4 }
size:2 capacity:8
{ 0 1 }
size:10 capacity:10
{ 0 1 2 3 4 5 6 7 8 9 }
size:9 capacity:10
{ 1 2 3 4 5 6 7 8 9 }
size:6 capacity:10
{ 1 2 6 7 8 9 }
size:3 capacity:10
{ 1 7 9 }
size:2 capacity:10
{ 7 9 }
size:1 capacity:10
{ 9 }
size:0 capacity:10
{ }

--- [33]:vector_pop_back_test ---
size:3 capacity:4
{ 5 3 4 }
size:2 capacity:4
{ 5 3 }
size:1 capacity:4
{ 5 }
size:0 capacity:4
{ }

--- [34]:vector_resize_test ---
size:0 capacity:0
{ }
size:5 capacity:5
{ 0 0 0 0 0 }
size:10 capacity:10
{ 0 0 0 0 0 10 10 10 10 10 }
size:1 capacity:10
{ 0 }
size:5 capacity:5
{ 1 2 3 4 5 }
size:10 capacity:10
{ 1 2 3 4 5 0 0 0 0 0 }

--- [35]:vector_swap_test ---
size:3 capacity:3
{ 1 2 3 }
size:2 capacity:2
{ 4 5 }
2 5 1 4

size:2 capacity:2
{ 4 5 }
size:3 capacity:3
{ 1 2 3 }
2 5 1 4
size:2 capacity:2
{ 4 5 }
size:3 capacity:3
{ 1 2 3 }
2 5 1 4

--- [36]:vector_nonmember_operator_test ---
alice == bob returns false
alice != bob returns true
alice <  bob returns true
alice <= bob returns true
alice >  bob returns false
alice >= bob returns false

alice == eve returns true
alice != eve returns false
alice <  eve returns false
alice <= eve returns true
alice >  eve returns false
alice >= eve returns true

--- [37]:vector_nonmember_swap_test ---
alice:size:3 capacity:3
{ 1 2 3 }

bob  :size:4 capacity:4
{ 7 8 9 10 }

-- alice.swap(bob)
alice:size:4 capacity:4
{ 7 8 9 10 }

bob  :size:3 capacity:3
{ 1 2 3 }

-- std::swap()
alice:size:3 capacity:3
{ 1 2 3 }

bob  :size:4 capacity:4
{ 7 8 9 10 }


--- [38]:stack_constructer_test ---
size of first: 0
size of third: 0
size of fourth: 2

--- [39]:stack_empty_test ---
total: 55

--- [40]:stack_size_test ---
0. size: 0
1. size: 5
2. size: 4

--- [41]:stack_top_test ---
mystack.top() is now 15

--- [42]:stack_push_test ---
Popping out elements... 4 3 2 1 0

--- [43]:stack_nonmember_operator_test ---
alice == bob returns false
alice != bob returns true
alice <  bob returns true
alice <= bob returns true
alice >  bob returns false
alice >= bob returns false

alice == eve returns true
alice != eve returns false
alice <  eve returns false
alice <= eve returns true
alice >  eve returns false
alice >= eve returns true

--- [44]:map_insert_test ---
--- M.insert({0,0}) ---
 size:1
 ret:0,0 true

--- M.insert({-1,-1}) ---
 size:2
 ret:-1,-1 true

--- M.insert({-2,-2}) ---
 size:3
 ret:-2,-2 true

--- M.insert({-3,-3}) ---
 size:4
 ret:-3,-3 true

--- M.insert({-4,-4}) ---
 size:5
 ret:-4,-4 true

--- M.insert({-5,-5}) ---
 size:6
 ret:-5,-5 true

--- M.insert({-6,-6}) ---
 size:7
 ret:-6,-6 true

--- M.insert({-7,-7}) ---
 size:8
 ret:-7,-7 true

--- M.insert({-8,-8}) ---
 size:9
 ret:-8,-8 true

--- M.insert({-9,-9}) ---
 size:10
 ret:-9,-9 true

--- M.insert({-10,-10}) ---
 size:11
 ret:-10,-10 true

--- M.insert({-11,-11}) ---
 size:12
 ret:-11,-11 true

--- M.insert({-12,-12}) ---
 size:13
 ret:-12,-12 true

--- M.insert({-13,-13}) ---
 size:14
 ret:-13,-13 true

--- M.insert({-14,-14}) ---
 size:15
 ret:-14,-14 true

--- M.insert({-15,-15}) ---
 size:16
 ret:-15,-15 true

--- M.insert({-16,-16}) ---
 size:17
 ret:-16,-16 true

--- M.insert({-17,-17}) ---
 size:18
 ret:-17,-17 true

--- M.insert({-18,-18}) ---
 size:19
 ret:-18,-18 true

--- M.insert({-19,-19}) ---
 size:20
 ret:-19,-19 true


--- [45]:map_value_compare_test ---
true
false

--- [46]:map_operator_equal_test ---
Initially:
---nums1---
size:10
M[0]:0
M[1]:1
M[2]:2
M[3]:3
M[4]:4
M[5]:5
M[6]:6
M[7]:7
M[8]:8
M[9]:9

---nums2---
size:0

After assigment:
---nums1---
size:10
M[0]:0
M[1]:1
M[2]:2
M[3]:3
M[4]:4
M[5]:5
M[6]:6
M[7]:7
M[8]:8
M[9]:9

---nums2---
size:10
M[0]:0
M[1]:1
M[2]:2
M[3]:3
M[4]:4
M[5]:5
M[6]:6
M[7]:7
M[8]:8
M[9]:9


--- [47]:map_all_erase_test ---
ins:0
size:5
M[0]:0
M[1]:1
M[2]:2
M[3]:3
M[4]:4

ers:0
size:0

ins:1
size:5
M[0]:0
M[1]:1
M[2]:2
M[3]:3
M[4]:4

ers:1
size:0

ins:2
size:5
M[0]:0
M[1]:1
M[2]:2
M[3]:3
M[4]:4

ers:2
size:0

ins:3
size:5
M[0]:0
M[1]:1
M[2]:2
M[3]:3
M[4]:4

ers:3
size:0

ins:4
size:5
M[0]:0
M[1]:1
M[2]:2
M[3]:3
M[4]:4

ers:4
size:0


--- [48]:map_get_alloc_test ---
1

--- [49]:map_at_test ---
a
exception std::out_of_range
a
exception std::out_of_range

--- [50]:map_insert_iterator_test ---
---M.insert(M.end(), ft::make_pair(4,2))---
ret[4]:4
size:10
M[0]:0
M[2]:2
M[4]:4
M[6]:6
M[8]:8
M[10]:10
M[12]:12
M[14]:14
M[16]:16
M[18]:18

---M.insert(M.begin(), ft::make_pair(4,2))---
ret[4]:4
size:10
M[0]:0
M[2]:2
M[4]:4
M[6]:6
M[8]:8
M[10]:10
M[12]:12
M[14]:14
M[16]:16
M[18]:18

---M.insert(M.end(), ft::make_pair(5,2))---
ret[5]:2
size:11
M[0]:0
M[2]:2
M[4]:4
M[5]:2
M[6]:6
M[8]:8
M[10]:10
M[12]:12
M[14]:14
M[16]:16
M[18]:18

---M.insert(M.begin(), ft::make_pair(7,2))---
ret[7]:2
size:12
M[0]:0
M[2]:2
M[4]:4
M[5]:2
M[6]:6
M[7]:2
M[8]:8
M[10]:10
M[12]:12
M[14]:14
M[16]:16
M[18]:18


--- [51]:map_insert_iterator_iterator_test ---
size:20
M[0]:0
M[1]:1
M[2]:2
M[3]:3
M[4]:4
M[5]:5
M[6]:6
M[7]:7
M[8]:8
M[9]:9
M[10]:10
M[11]:11
M[12]:12
M[13]:13
M[14]:14
M[15]:15
M[16]:16
M[17]:17
M[18]:18
M[19]:19

size:20
M[0]:0
M[1]:1
M[2]:2
M[3]:3
M[4]:4
M[5]:5
M[6]:6
M[7]:7
M[8]:8
M[9]:9
M[10]:10
M[11]:11
M[12]:12
M[13]:13
M[14]:14
M[15]:15
M[16]:16
M[17]:17
M[18]:18
M[19]:19


--- [52]:map_operator_kakko_test ---
size:6
M[0]:0
M[1]:0
M[2]:0
M[3]:3
M[4]:4
M[5]:5

size:10
M[0]:100
M[1]:101
M[2]:102
M[3]:103
M[4]:104
M[5]:105
M[6]:106
M[7]:107
M[8]:108
M[9]:109

The magnitude of (1, 1) is 1.41421
The magnitude of (2, 2) is 2.82843
The magnitude of (3, 3) is 4.24264
The magnitude of (1, 1.41421) is 1.73205
The magnitude of (2, 2.82843) is 3.4641
The magnitude of (3, 4.24264) is 5.19615
The magnitude of (1, 1.41421) is 1.73205
The magnitude of (2, 2.82843) is 3.4641
The magnitude of (3, 4.24264) is 5.19615
The magnitude of (1, 1.73205) is const
The magnitude of (2, 3.4641) is const
The magnitude of (3, 5.19615) is const

--- [53]:map_rbegin_test ---
US coins in circulation, largest to smallest denomination:
     dollar = ¢100
half_dollar = ¢50
    quarter = ¢25
       dime = ¢10
     nickel = ¢5
      penny = ¢1
US coins in circulation, largest to smallest denomination:
     dollar = ¢100
half_dollar = ¢50
    quarter = ¢25
       dime = ¢10
     nickel = ¢5
      penny = ¢1

--- [54]:map_empty_test ---
ins:true size:0
ers:true size:0
ins:false size:1
ers:true size:0
ins:false size:2
ers:true size:0
ins:false size:3
ers:true size:0
ins:false size:4
ers:true size:0

--- [55]:map_max_size_test ---
int:461168601842738790
char:461168601842738790

--- [56]:map_clear_test ---
ins:0
size:0

clear
size:0

ins:1
size:1
M[-100]:-100

clear
size:0

ins:2
size:2
M[-100]:-100
M[-99]:-99

clear
size:0

ins:3
size:3
M[-100]:-100
M[-99]:-99
M[-98]:-98

clear
size:0

ins:4
size:4
M[-100]:-100
M[-99]:-99
M[-98]:-98
M[-97]:-97

clear
size:0


--- [57]:map_erase_test ---
erase_key:0 ret:1
erase_key:1 ret:1
erase_key:2 ret:1
erase_key:3 ret:1
erase_key:4 ret:1
erase_key:5 ret:0
erase_key:6 ret:0
erase_key:7 ret:0
erase_key:8 ret:0
erase_key:9 ret:0
M.erase(0)
size:4
M[1]:1
M[2]:2
M[3]:3
M[4]:4

M.erase(1)
size:3
M[2]:2
M[3]:3
M[4]:4

M.erase(2)
size:2
M[3]:3
M[4]:4

M.erase(3)
size:1
M[4]:4

M.erase(4)
size:0

M.erase(0,0)
size:5
M[0]:0
M[1]:1
M[2]:2
M[3]:3
M[4]:4

M.erase(0,1)
size:4
M[1]:1
M[2]:2
M[3]:3
M[4]:4

M.erase(0,2)
size:3
M[2]:2
M[3]:3
M[4]:4

M.erase(0,3)
size:2
M[3]:3
M[4]:4

M.erase(0,4)
size:1
M[4]:4

M.erase(4,M.end())
size:4
M[0]:0
M[1]:1
M[2]:2
M[3]:3

M.erase(3,M.end())
size:3
M[0]:0
M[1]:1
M[2]:2

M.erase(2,M.end())
size:2
M[0]:0
M[1]:1

M.erase(1,M.end())
size:1
M[0]:0

M.erase(0,M.end())
size:0


--- [58]:map_swap_test ---
alice.swap(blank)
alice
size:0

size:3
M[1]:a
M[2]:b
M[3]:c

alice.swap(blank)
alice
size:3
M[1]:a
M[2]:b
M[3]:c

size:0

blank.swap(alice)
alice
size:3
M[1]:a
M[2]:b
M[3]:c

size:0

blank.swap(alice)
alice
size:3
M[1]:a
M[2]:b
M[3]:c

size:0

std::swap(alice, blank)
alice
size:0

size:3
M[1]:a
M[2]:b
M[3]:c

std::swap(alice, blank)
alice
size:3
M[1]:a
M[2]:b
M[3]:c

size:0

alice
size:3
M[1]:a
M[2]:b
M[3]:c

bob
size:4
M[7]:Z
M[8]:Y
M[9]:X
M[10]:W

alice
size:4
M[7]:Z
M[8]:Y
M[9]:X
M[10]:W

bob
size:3
M[1]:a
M[2]:b
M[3]:c

std::swap(alice, bob)
alice
size:3
M[1]:a
M[2]:b
M[3]:c

bob
size:4
M[7]:Z
M[8]:Y
M[9]:X
M[10]:W

alice.swap(bob)
alice
size:4
M[7]:Z
M[8]:Y
M[9]:X
M[10]:W

bob
size:3
M[1]:a
M[2]:b
M[3]:c

bob.swap(alice)
alice
size:3
M[1]:a
M[2]:b
M[3]:c

bob
size:4
M[7]:Z
M[8]:Y
M[9]:X
M[10]:W


--- [59]:map_find_test ---
M[0]:0 count:1
M[1]:1 count:1
M[2]:2 count:1
M[3]:end() count:0
M[4]:end() count:0
M[0]:0 count:1
M[1]:1 count:1
M[2]:2 count:1
M[3]:end() count:0
M[4]:end() count:0

--- [60]:map_equal_range_test ---
m[1] = one
end of equal_range (p.second) is one-past p.first
pp.first is iterator to first not-less than -1
pp.second is iterator to first element greater-than -1
ppp.first is iterator to first not-less than 3
ppp.second is iterator to first element greater-than 3

--- [61]:map_copy_construct_test ---
size:3
M[0]:zero
M[1]:one
M[2]:two

size:3
M[0]:zero
M[1]:one
M[2]:two

size:3
M[0]:zero
M[1]:one
M[2]:two

M.lower_bound(0):3
M.lower_bound(1):3
M.lower_bound(2):3
M.lower_bound(3):3
M.lower_bound(4):4
M.lower_bound(5):5
M.lower_bound(6):6
M.lower_bound(7):7
M.lower_bound(8):end()
M.lower_bound(9):end()
M.upper_bound(0):3
M.upper_bound(1):3
M.upper_bound(2):3
M.upper_bound(3):4
M.upper_bound(4):5
M.upper_bound(5):6
M.upper_bound(6):7
M.upper_bound(7):end()
M.upper_bound(8):end()
M.upper_bound(9):end()
CM.lower_bound(0):3
CM.lower_bound(1):3
CM.lower_bound(2):3
CM.lower_bound(3):3
CM.lower_bound(4):4
CM.lower_bound(5):5
CM.lower_bound(6):6
CM.lower_bound(7):7
CM.lower_bound(8):end()
CM.lower_bound(9):end()
CM.upper_bound(0):3
CM.upper_bound(1):3
CM.upper_bound(2):3
CM.upper_bound(3):4
CM.upper_bound(4):5
CM.upper_bound(5):6
CM.upper_bound(6):7
CM.upper_bound(7):end()
CM.upper_bound(8):end()
CM.upper_bound(9):end()

--- [62]:map_key_comp_test ---
1 goes before key 100
2 goes before key 100
3 equivalent to key 100
4 goes after key 100
5 goes after key 100

--- [63]:map_value_comp_test ---
1 goes before key 100
2 goes before key 100
3 equivalent to key 100
4 goes after key 100
5 goes after key 100
alice == bob returns false
alice != bob returns true
alice <  bob returns true
alice <= bob returns true
alice >  bob returns false
alice >= bob returns false

alice == eve returns true
alice != eve returns false
alice <  eve returns false
alice <= eve returns true
alice >  eve returns false
alice >= eve returns true

--- [64]:map_constructs_test ---
map1 = size:3
M[anything]:199
M[something]:69
M[that thing]:50


iter = size:3
M[anything]:199
M[something]:69
M[that thing]:50

map1 = size:3
M[anything]:199
M[something]:69
M[that thing]:50


iter2 = size:2
M[something]:69
M[that thing]:50

map1 = size:3
M[anything]:199
M[something]:69
M[that thing]:50


copied = size:3
M[anything]:199
M[something]:69
M[that thing]:50

map1 = size:3
M[anything]:199
M[something]:69
M[that thing]:50

The magnitude of (-8, -15) is 17
The magnitude of (3, 4) is 5
The magnitude of (5, -12) is 13

--- [65]:set_insert_test ---
--- S.insert(0) ---
 size:1
 ret:0
--- S.insert(-1) ---
 size:2
 ret:-1
--- S.insert(-2) ---
 size:3
 ret:-2
--- S.insert(-3) ---
 size:4
 ret:-3
--- S.insert(-4) ---
 size:5
 ret:-4
--- S.insert(-5) ---
 size:6
 ret:-5
--- S.insert(-6) ---
 size:7
 ret:-6
--- S.insert(-7) ---
 size:8
 ret:-7
--- S.insert(-8) ---
 size:9
 ret:-8
--- S.insert(-9) ---
 size:10
 ret:-9
--- S.insert(-10) ---
 size:11
 ret:-10
--- S.insert(-11) ---
 size:12
 ret:-11
--- S.insert(-12) ---
 size:13
 ret:-12
--- S.insert(-13) ---
 size:14
 ret:-13
--- S.insert(-14) ---
 size:15
 ret:-14
--- S.insert(-15) ---
 size:16
 ret:-15
--- S.insert(-16) ---
 size:17
 ret:-16
--- S.insert(-17) ---
 size:18
 ret:-17
--- S.insert(-18) ---
 size:19
 ret:-18
--- S.insert(-19) ---
 size:20
 ret:-19

--- [66]:set_operator_equal_test ---
Initially:
---nums1---
size:10
S[0]
S[1]
S[2]
S[3]
S[4]
S[5]
S[6]
S[7]
S[8]
S[9]

---nums2---
size:0

After assigment:
---nums1---
size:10
S[0]
S[1]
S[2]
S[3]
S[4]
S[5]
S[6]
S[7]
S[8]
S[9]

---nums2---
size:10
S[0]
S[1]
S[2]
S[3]
S[4]
S[5]
S[6]
S[7]
S[8]
S[9]


--- [67]:set_all_erase_test ---
ins:0
size:5
S[0]
S[1]
S[2]
S[3]
S[4]

ers:0
size:0

ins:1
size:5
S[0]
S[1]
S[2]
S[3]
S[4]

ers:1
size:0

ins:2
size:5
S[0]
S[1]
S[2]
S[3]
S[4]

ers:2
size:0

ins:3
size:5
S[0]
S[1]
S[2]
S[3]
S[4]

ers:3
size:0

ins:4
size:5
S[0]
S[1]
S[2]
S[3]
S[4]

ers:4
size:0


--- [68]:set_get_alloc_test ---
1

--- [69]:set_insert_iterator_test ---
---S.insert(S.end(), 4)---
ret:4
size:10
S[0]
S[2]
S[4]
S[6]
S[8]
S[10]
S[12]
S[14]
S[16]
S[18]

---S.insert(S.begin(), 4)---
ret:4
size:10
S[0]
S[2]
S[4]
S[6]
S[8]
S[10]
S[12]
S[14]
S[16]
S[18]

---S.insert(S.end(), 5)---
ret:5
size:11
S[0]
S[2]
S[4]
S[5]
S[6]
S[8]
S[10]
S[12]
S[14]
S[16]
S[18]

---S.insert(S.begin(), 7)---
ret:7
size:12
S[0]
S[2]
S[4]
S[5]
S[6]
S[7]
S[8]
S[10]
S[12]
S[14]
S[16]
S[18]


--- [70]:set_insert_iterator_iterator_test ---
size:20
S[0]
S[1]
S[2]
S[3]
S[4]
S[5]
S[6]
S[7]
S[8]
S[9]
S[10]
S[11]
S[12]
S[13]
S[14]
S[15]
S[16]
S[17]
S[18]
S[19]

size:20
S[0]
S[1]
S[2]
S[3]
S[4]
S[5]
S[6]
S[7]
S[8]
S[9]
S[10]
S[11]
S[12]
S[13]
S[14]
S[15]
S[16]
S[17]
S[18]
S[19]

The magnitude of (1, 0) is 1
The magnitude of (2, 0) is 2
The magnitude of (3, 0) is 3
The magnitude of (1, 0) is 1
The magnitude of (2, 0) is 2
The magnitude of (3, 0) is 3

--- [71]:set_rbegin_test ---
set_rbegin_test_out
4 3 2 1 0 
set_rbegin_test_const_out
4 3 2 1 0 

--- [72]:set_empty_test ---
ins:true size:0
ins:false size:1
ers:true size:0
ins:false size:2
ers:false size:1
ers:true size:0
ins:false size:3
ers:false size:2
ers:false size:1
ers:true size:0
ins:false size:4
ers:false size:3
ers:false size:2
ers:false size:1
ers:true size:0

--- [73]:set_max_size_test ---
int:461168601842738790
char:461168601842738790

--- [74]:set_clear_test ---
ins:0
size:0

clear
size:0

ins:1
size:1
S[-100]

clear
size:0

ins:2
size:2
S[-100]
S[-99]

clear
size:0

ins:3
size:3
S[-100]
S[-99]
S[-98]

clear
size:0

ins:4
size:4
S[-100]
S[-99]
S[-98]
S[-97]

clear
size:0


--- [75]:set_erase_test ---
erase_key:0 ret:1
erase_key:1 ret:1
erase_key:2 ret:1
erase_key:3 ret:1
erase_key:4 ret:1
erase_key:5 ret:0
erase_key:6 ret:0
erase_key:7 ret:0
erase_key:8 ret:0
erase_key:9 ret:0
S.erase(0)
size:4
S[1]
S[2]
S[3]
S[4]

S.erase(1)
size:3
S[2]
S[3]
S[4]

S.erase(2)
size:2
S[3]
S[4]

S.erase(3)
size:1
S[4]

S.erase(4)
size:0

S.erase(0,0)
size:5
S[0]
S[1]
S[2]
S[3]
S[4]

S.erase(0,1)
size:4
S[1]
S[2]
S[3]
S[4]

S.erase(0,2)
size:3
S[2]
S[3]
S[4]

S.erase(0,3)
size:2
S[3]
S[4]

S.erase(0,4)
size:1
S[4]

S.erase(4,S.end())
size:4
S[0]
S[1]
S[2]
S[3]

S.erase(3,S.end())
size:3
S[0]
S[1]
S[2]

S.erase(2,S.end())
size:2
S[0]
S[1]

S.erase(1,S.end())
size:1
S[0]

S.erase(0,S.end())
size:0


--- [76]:set_swap_test ---
alice.swap(blank)
alice
size:0

size:3
S[a]
S[b]
S[c]

alice.swap(blank)
alice
size:3
S[a]
S[b]
S[c]

size:0

blank.swap(alice)
alice
size:3
S[a]
S[b]
S[c]

size:0

blank.swap(alice)
alice
size:3
S[a]
S[b]
S[c]

size:0

std::swap(alice, blank)
alice
size:0

size:3
S[a]
S[b]
S[c]

std::swap(alice, blank)
alice
size:3
S[a]
S[b]
S[c]

size:0

alice
size:3
S[a]
S[b]
S[c]

bob
size:4
S[W]
S[X]
S[Y]
S[Z]

alice
size:4
S[W]
S[X]
S[Y]
S[Z]

bob
size:3
S[a]
S[b]
S[c]

std::swap(alice, bob)
alice
size:3
S[a]
S[b]
S[c]

bob
size:4
S[W]
S[X]
S[Y]
S[Z]

alice.swap(bob)
alice
size:4
S[W]
S[X]
S[Y]
S[Z]

bob
size:3
S[a]
S[b]
S[c]

bob.swap(alice)
alice
size:3
S[a]
S[b]
S[c]

bob
size:4
S[W]
S[X]
S[Y]
S[Z]


--- [77]:set_find_test ---
S:0 count:1
S:1 count:1
S:2 count:1
S:end() count:0
S:end() count:0
S[0]:0 count:1
S[1]:1 count:1
S[2]:2 count:1
S[3]:end() count:0
S[4]:end() count:0

--- [78]:set_equal_range_test ---
s[one] 
end of equal_range (p.second) is one-past p.first
s[one] 
end of equal_range (p.second) is one-past p.first
unexpected pp.first
unexpected pp.second
ppp.first is iterator to first not-less than 3
ppp.second is iterator to first element greater-than 3

--- [79]:set_copy_construct_test ---
size:3
S[zero]
S[one]
S[two]

size:3
S[zero]
S[one]
S[two]

size:3
S[zero]
S[one]
S[two]

S.lower_bound(0):3
S.lower_bound(1):3
S.lower_bound(2):3
S.lower_bound(3):3
S.lower_bound(4):4
S.lower_bound(5):5
S.lower_bound(6):6
S.lower_bound(7):7
S.lower_bound(8):end()
S.lower_bound(9):end()
S.upper_bound(0):3
S.upper_bound(1):3
S.upper_bound(2):3
S.upper_bound(3):4
S.upper_bound(4):5
S.upper_bound(5):6
S.upper_bound(6):7
S.upper_bound(7):end()
S.upper_bound(8):end()
S.upper_bound(9):end()
CS.lower_bound(0):3
CS.lower_bound(1):3
CS.lower_bound(2):3
CS.lower_bound(3):3
CS.lower_bound(4):4
CS.lower_bound(5):5
CS.lower_bound(6):6
CS.lower_bound(7):7
CS.lower_bound(8):end()
CS.lower_bound(9):end()
CS.upper_bound(0):3
CS.upper_bound(1):3
CS.upper_bound(2):3
CS.upper_bound(3):4
CS.upper_bound(4):5
CS.upper_bound(5):6
CS.upper_bound(6):7
CS.upper_bound(7):end()
CS.upper_bound(8):end()
CS.upper_bound(9):end()

--- [80]:set_key_comp_test ---
1 goes before key 100
2 goes before key 100
3 equivalent to key 100
4 goes after key 100
5 goes after key 100

--- [81]:set_value_comp_test ---
1 goes before key 100
2 goes before key 100
3 equivalent to key 100
4 goes after key 100
5 goes after key 100
alice == bob returns false
alice != bob returns true
alice <  bob returns false
alice <= bob returns false
alice >  bob returns true
alice >= bob returns true

alice == eve returns true
alice != eve returns false
alice <  eve returns false
alice <= eve returns true
alice >  eve returns false
alice >= eve returns true

--- [82]:set_constructs_test ---
size:3
S[cat]
S[dog]
S[horse]

size:3
S[cat]
S[dog]
S[horse]

size:2
S[dog]
S[horse]

size:4
S[another horse]
S[cat]
S[dog]
S[horse]

(1,1) (2,5) (3,4) 

--- [83]:is_integral_test ---
true:int is integral
true:value_type == bool
true:type == true_type
false:value == false, int* is not integral
true:value_type == bool
true:type == false_type
true:bool is integral
true:char is integral
true:char32_t is integral
true:const long long is integral
true:volatile unsigned is integral
false:my_enum is not integral
false:int& is not integral
false:int[1] is not integral
false:int () is not integral
false:float is not integral
true:bool is integral
true:char is integral
true:char16 is integral
true:char32 is integral
true:wchar is integral
true:short is integral
true:int is integral
true:long is integral
true:longlong is integral
false:V.end() is not integral
1

--- [84]:review_vector_dynamic_array ---
size:0 capacity:0
{ }
size:1 capacity:1
{ 0 }
size:2 capacity:2
{ 0 1 }
size:3 capacity:4
{ 0 1 2 }
size:4 capacity:4
{ 0 1 2 3 }
size:5 capacity:8
{ 0 1 2 3 4 }
size:6 capacity:8
{ 0 1 2 3 4 5 }
size:7 capacity:8
{ 0 1 2 3 4 5 6 }
size:8 capacity:8
{ 0 1 2 3 4 5 6 7 }
size:9 capacity:16
{ 0 1 2 3 4 5 6 7 8 }
size:10 capacity:16
{ 0 1 2 3 4 5 6 7 8 9 }

--- [85]:review_vector_comp_cit_it ---
0 0
1 1
2 2
3 3
4 4
5 5
6 6
7 7
8 8
9 9

--- [86]:review_vector_swap ---
<before swap>
size:10 capacity:16
{ 0 1 2 3 4 5 6 7 8 9 }
size:20 capacity:32
{ 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 }
<after swap>

size:20 capacity:32
{ 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 }
size:10 capacity:16
{ 0 1 2 3 4 5 6 7 8 9 }
<after std::swap(V, V2)>

size:10 capacity:16
{ 0 1 2 3 4 5 6 7 8 9 }
size:20 capacity:32
{ 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 }

--- [87]:review_vector_refer_elements ---
<before>
0 0 0
<after>
42 42 42
<after>
43 43 43

--- [88]:review_map_make_pair ---
size:4
M[-42]:d
M[0]:b
M[30]:c
M[100]:a

<insert twice>
size:4
M[-42]:d
M[0]:b
M[30]:c
M[100]:a


--- [89]:review_map_insert_delete ---
size:10
M[0]:0
M[1]:1
M[2]:2
M[3]:3
M[4]:4
M[5]:5
M[6]:6
M[7]:7
M[8]:8
M[9]:9

<erase>:5
size:9
M[0]:0
M[1]:1
M[2]:2
M[3]:3
M[4]:4
M[6]:6
M[7]:7
M[8]:8
M[9]:9

<erase>:6
size:8
M[0]:0
M[1]:1
M[2]:2
M[3]:3
M[4]:4
M[7]:7
M[8]:8
M[9]:9

<erase>:7
size:7
M[0]:0
M[1]:1
M[2]:2
M[3]:3
M[4]:4
M[8]:8
M[9]:9

<erase>:8
size:6
M[0]:0
M[1]:1
M[2]:2
M[3]:3
M[4]:4
M[9]:9

<erase>:9
size:5
M[0]:0
M[1]:1
M[2]:2
M[3]:3
M[4]:4

<erase>:0
size:4
M[1]:1
M[2]:2
M[3]:3
M[4]:4

<erase>:1
size:3
M[2]:2
M[3]:3
M[4]:4

<erase>:2
size:2
M[3]:3
M[4]:4

<erase>:3
size:1
M[4]:4

<erase>:4
size:0

<erase>:5
size:0

<erase>:6
size:0

<erase>:7
size:0


--- [90]:review_map_swap ---
alice.swap(blank)
alice
size:0

size:3
M[1]:a
M[2]:b
M[3]:c

alice.swap(blank)
alice
size:3
M[1]:a
M[2]:b
M[3]:c

size:0

blank.swap(alice)
alice
size:3
M[1]:a
M[2]:b
M[3]:c

size:0

blank.swap(alice)
alice
size:3
M[1]:a
M[2]:b
M[3]:c

size:0

std::swap(alice, blank)
alice
size:0

size:3
M[1]:a
M[2]:b
M[3]:c

std::swap(alice, blank)
alice
size:3
M[1]:a
M[2]:b
M[3]:c

size:0

alice
size:3
M[1]:a
M[2]:b
M[3]:c

bob
size:4
M[7]:Z
M[8]:Y
M[9]:X
M[10]:W

alice
size:4
M[7]:Z
M[8]:Y
M[9]:X
M[10]:W

bob
size:3
M[1]:a
M[2]:b
M[3]:c

std::swap(alice, bob)
alice
size:3
M[1]:a
M[2]:b
M[3]:c

bob
size:4
M[7]:Z
M[8]:Y
M[9]:X
M[10]:W

alice.swap(bob)
alice
size:4
M[7]:Z
M[8]:Y
M[9]:X
M[10]:W

bob
size:3
M[1]:a
M[2]:b
M[3]:c

bob.swap(alice)
alice
size:3
M[1]:a
M[2]:b
M[3]:c

bob
size:4
M[7]:Z
M[8]:Y
M[9]:X
M[10]:W


--- [91]:review_stack_test ---
123
